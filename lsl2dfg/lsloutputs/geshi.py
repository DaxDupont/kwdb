#!/usr/bin/env python

# geshi.py - This is a LSL2dfg.py output module for GeSHi PHP Generic Syntax Highlighting.
#
# (C) Copyright 2013 Sei Lisa.
# Sei Lisa is the author's username in the Second Life online virtual world.
#
# This file is part of LSL2 Derived Files Generator.
#
#    LSL2 Derived Files Generator is free software: you can redistribute it
#    and/or modify it under the terms of the GNU Lesser General Public License
#    as published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    LSL2 Derived Files Generator is distributed in the hope that it will be
#    useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with LSL2 Derived Files Generator. If not, see
#    <http://www.gnu.org/licenses/>.
#
# Second Life is a trademark of Linden Research, Inc.


import sys

def output(document, defaultdescs, databaseversion, infilename, outfilename, lang, tag):

  version = "0.0.20130711000"

  keywords = []
  types = []
  constants = []
  functions = []
  events = []
  deprecated = []
  unimplemented = []
  godmode = []

  for element in document:
    if element["cat"] == "keyword":
      if "status" not in element or element["status"] == "normal":
        if element["name"] not in ("default", "print"):
          keywords.append(element["name"])
        else:
          functions.append(element["name"])
      elif element["status"] in ("deprecated", "unimplemented"):
        unimplemented.append(element["name"])
      else:
        raise Exception("Unknown status in '%s' keyword: %s" % (element["name"], element["status"]))
    elif element["cat"] == "type":
      types.append(element["name"])
    elif element["cat"] == "constant":
      if "status" not in element or element["status"] == "normal":
        constants.append(element["name"])
      elif element["status"] in ("deprecated", "unimplemented"):
        deprecated.append(element["name"])
      else:
        raise Exception("Unknown status in '%s' constant: %s" % (element["name"], element["status"]))
    elif element["cat"] == "function":
      if "status" in element:
        if element["status"] == "deprecated":
          deprecated.append(element["name"])
        elif element["status"] == "unimplemented":
          unimplemented.append(element["name"])
        elif element["status"] == "godmode":
          godmode.append(element["name"])
        elif element["status"] == "normal":
          functions.append(element["name"])
        else:
          raise Exception("Unknown status: " + element["status"])
      else:
        functions.append(element["name"])
    elif element["cat"] == "event":
      events.append(element["name"])

  keywords.sort()
  types.sort()
  constants.sort()
  functions.sort(lambda x,y: cmp(x.lower(), y.lower()))
  events.sort()
  deprecated.sort()
  unimplemented.sort()
  godmode.sort()

  if infilename is not None:
    inf = open(infilename, "r")
  else:
    inf = sys.stdin

  try:
    geshi = inf.readlines()

  finally:
    if infilename is not None:
      inf.close()

  if outfilename is not None:
    outf = open(outfilename, "w")
  else:
    outf = sys.stdout

  try:

    for line in geshi:
      if not line.startswith("<<< %s KEYWORDS >>>" % tag):
        outf.write(line)
      else:
        outf.write("// Generated by LSL2 Derived Files Generator. Database version: %s; output module version: %s\n"
          % (databaseversion, version))

        outf.write("""        1 => array( // flow control\n""")
        for element in keywords:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        2 => array( // manifest constants\n""")
        for element in constants:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        3 => array( // handlers\n""")
        for element in events:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        4 => array( // data types\n""")
        for element in types:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        5 => array( // library\n""")
        for element in functions:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        6 => array( // deprecated\n""")
        for element in deprecated:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        7 => array( // unimplemented\n""")
        for element in unimplemented:
          outf.write("            '" + element + "',\n")
        outf.write("""            ),
        8 => array( // God mode\n""")
        for element in godmode:
          outf.write("            '" + element + "',\n")
        outf.write("            ),\n")

  finally:
    if outfilename is not None:
      outf.close()

pass
